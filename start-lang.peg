// Language Nodes

{
  var rawAsap = require('raw'),
      handle = require('start-lib')._handle,
      slice = Array.prototype.slice;

  function mixin(object, properties) {
    Object.keys(properties).forEach(function(prop) {
      object[prop] = properties[prop];
    });
  }

  function Node() {}

  Node.extend = function(options) {
    var delegate = options.constructor,
        ctor = function() {
          // grab the info about where we are in the source
          this._text = text();
          this._offset = offset();
          this._line = line();
          this._column = column();

          // copy from proto so we can inspect it
          this._node = this.node;

          delegate.apply(this, arguments);
        };

    ctor.prototype = Object.create(Node.prototype);
    options.constructor = ctor;
    mixin(ctor.prototype, options);
    return ctor;
  };

  mixin(Node.prototype, {
    // hook where we can determine how to proceed:
    //  - immediately with asap
    //  - broadcast an update to the UI before proceeding
    //  - stop at a breakpoint and resume
    //  - etc.
    eval_a: function(ctx, done) {
      var _this = this;
      rawAsap(function() {
        ctx.visit(_this, function retry() {
          try {
            _this.evaluate(ctx, done);
          } catch (err) {
            ctx.handleError(_this, err, retry, function() {
              err.node = _this;
              done(err);
            });
          }
        });
      });
    }
  });

  var Statements = Node.extend({
    node: 'statements',

    constructor: function(stmts) {
      this.stmts = stmts || [];
    },

    evaluate: function(ctx, done) {
      var _this = this, len = _this.stmts.length, count = -1;
      (function loop() {
        if (++count < len) {
          _this.stmts[count].eval_a(ctx, function(err) {
            if (err) {
              done(err);
            } else {
              loop();
            }
          });
        } else {
          done();
        }
      })();
    }
  });

  var IfBlock = Node.extend({
    node: 'if_block',

    constructor: function(cond, tstmts, fstmts) {
      this.cond = cond;
      this.tstmts = tstmts;
      this.fstmts = fstmts || new Statements();
    },

    evaluate: function(ctx, done) {
      var _this = this;
      _this.cond.eval_a(ctx, function(err, cres) {
        if (err) {
          done(err);
        } else {
          var todo = cres ? _this.tstmts : _this.fstmts;
          todo.eval_a(ctx, done);
        }
      });
    }
  });

  var ForBlock = Node.extend({
    node: 'for_block',

    constructor: function(name, range, stmts) {
      this.name = name;
      this.range = range;
      this.stmts = stmts;
    },

    evaluate: function(ctx, done) {
      var _this = this, items, len, count;
      _this.range.eval_a(ctx, function(err, rres) {
        if (err) {
          done(err);
        } else {
          items = handle(rres).enumerate(rres);
          len = items.length;
          count = -1;
          (function loop() {
            if (++count < len) {
              ctx.set(_this.name, items[count]);
              _this.stmts.eval_a(ctx, function(err) {
                if (err) {
                  if (err.flow && err.scope == 'loop') {
                    (err.terminate ? done : loop)();
                  } else {
                    done(err);
                  }
                } else {
                  loop();
                }
              });
            } else {
              done();
            }
          })();
        }
      });
    }
  });

  var WhileBlock = Node.extend({
    node: 'while_block',

    constructor: function(cond, stmts) {
      this.cond = cond;
      this.stmts = stmts;
    },

    evaluate: function(ctx, done) {
      var _this = this;
      (function loop() {
        _this.cond.eval_a(ctx, function(err, cres) {
          if (err) {
            done(err);
          } else if (cres) {
            _this.stmts.eval_a(ctx, function(err) {
              if (err) {
                if (err.flow && err.scope == 'loop') {
                  (err.terminate ? done : loop)();
                } else {
                  done(err);
                }
              } else {
                loop();
              }
            });
          } else {
            done();
          }
        });
      })();
    }
  });

  var BeginBlock = Node.extend({
    node: 'begin_block',

    constructor: function(name, stmts) {
      this.name = name;
      this.stmts = stmts;
    },

    evaluate: function(ctx, done) {
      ctx.set(this.name, this.invoke.bind(this));
      done();
    },

    invoke: function(ctx, args, done) {
      ctx.push();
      this.stmts.eval_a(ctx, function(err) {
        ctx.pop();
        if (err) {
          if (err.flow) {
            done(null, err.result);
          } else {
            done(err);
          }
        } else {
          done();
        }
      });
    }
  });

  var Funcall = Node.extend({
    node: 'funcall',

    constructor: function(target, args) {
      this.target = target;
      this.args = args || [];
    },

    evaluate: function(ctx, done) {
      var _this = this, len = _this.args.length, args = [], count = -1;
      _this.target.eval_a(ctx, function(err, tres) {
        if (err) {
          done(err);
        } else {
          (function loop() {
            if (++count < len) {
              _this.args[count].eval_a(ctx, function(err, ares) {
                if (err) {
                  done(err);
                } else {
                  args[count] = ares;
                  loop();
                }
              });
            } else {
              if (tres) {
                tres(ctx, args, done);
              } else {
                done(null, ctx.syscall(_this.target.name, args));
              }
            }
          })();
        }
      });
    }
  });

  var Break = Node.extend({
    node: 'break',

    evaluate: function(ctx, done) {
      done({
        flow: true,
        terminate: true,
        scope: 'loop'
      });
    }
  });

  var Next = Node.extend({
    node: 'next',

    evaluate: function(ctx, done) {
      done({
        flow: true,
        terminate: false,
        scope: 'loop'
      });
    }
  });

  var Return = Node.extend({
    node: 'return',

    constructor: function(result) {
      this.result = result;
    },

    evaluate: function(ctx, done) {
      if (this.result) {
        this.result.eval_a(ctx, function(err, rres) {
          if (err) {
            done(err);
          } else {
            done({
              flow: true,
              terminate: true,
              scope: 'function',
              result: rres
            });
          }
        });
      } else {
        done({
          flow: true,
          terminate: true,
          scope: 'function'
        });
      }
    }
  });

  var Variable = Node.extend({
    node: 'variable',

    constructor: function(name, index) {
      this.name = name;
    },

    evaluate: function(ctx, done) {
      done(null, ctx.get(this.name));
    }
  });

  var Assignment = Node.extend({
    node: 'assignment',

    constructor: function(name, value) {
      this.name = name;
      this.value = value;
    },

    evaluate: function(ctx, done) {
      var _this = this;
      _this.value.eval_a(ctx, function(err, vres) {
        if (err) {
          done(err);
        } else {
          ctx.set(_this.name, vres);
          done();
        }
      });
    }
  });

  var Index = Node.extend({
    node: 'index',

    constructor: function(base, index) {
      this.base = base;
      this.index = index;
    },

    evaluate: function(ctx, done) {
      var _this = this;

      _this.base.eval_a(ctx, function(err, bres) {
        if (err) {
          done(err);
        } else {
          _this.index.eval_a(ctx, function(err, ires) {
            if (err) {
              done(err);
            } else {
              done(null, ctx.getindex(bres, ires));
            }
          });
        }
      });
    }
  });

  var IndexAssignment = Node.extend({
    node: 'index_assignment',

    constructor: function(base, index, value) {
      this.base = base;
      this.index = index;
      this.value = value;
    },

    evaluate: function(ctx, done) {
      var _this = this;

      _this.base.eval_a(ctx, function(err, bres) {
        if (err) {
          done(err);
        } else {
          _this.index.eval_a(ctx, function(err, ires) {
            if (err) {
              done(err);
            } else {
              _this.value.eval_a(ctx, function(err, vres) {
                if (err) {
                  done(err);
                } else {
                  ctx.setindex(bres, ires, vres);
                  done();
                }
              });
            }
          });
        }
      });
    }
  });

  function buildIndex(base, indexes, value) {
    indexes || (indexes = []);

    var next, last = indexes.pop();

    while (next = indexes.shift()) {
      base = new Index(base, next);
    }

    if (value == null) {
      return new Index(base, last);
    } else {
      return new IndexAssignment(base, last, value);
    }
  }

  var Literal = Node.extend({
    node: 'literal',

    constructor: function(value) {
      this.value = value;
    },

    evaluate: function(ctx, done) {
      done(null, this.value);
    }
  });

  var Comment = Node.extend({
    node: 'comment',

    constructor: function(text) {
      this.text = text;
    },

    evaluate: function(ctx, done) {
      done();
    }
  });

  var LogicalOp = Node.extend({
    node: 'logical_op',

    constructor: function(op, left, right) {
      this.op = op;
      this.left = left;
      this.right = right;
    },

    evaluate: function(ctx, done) {
      // logical ops short-circuit
      logicalOps[this.op](ctx, this.left, this.right, done);
    }
  });

  var logicalOps = {
    'and': function(ctx, left, right, done) {
      left.eval_a(ctx, function(err, lres) {
        if (err) {
          done(err);
        } else if (!lres) {
          done(null, false);
        } else {
          right.eval_a(ctx, function(err, rres) {
            if (err) {
              done(err);
            } else {
              done(null, !!rres);
            }
          });
        }
      });
    },

    'or': function(ctx, left, right, done) {
      left.eval_a(ctx, function(err, lres) {
        if (err) {
          done(err);
        } else if (lres) {
          done(null, true);
        } else {
          right.eval_a(ctx, function(err, rres) {
            if (err) {
              done(err);
            } else {
              done(null, !!rres);
            }
          });
        }
      });
    },

    'not': function(ctx, left, right, done) {
      right.eval_a(ctx, function(err, rres) {
        if (err) {
          done(err);
        } else {
          done(null, !rres);
        }
      });
    }
  };

  // take a chain of equal-precedence logical exprs and construct a left-folding tree
  function buildLogicalOp(first, rest) {
    if (rest.length == 0) {
      return first;
    } else {
      var next = rest.shift();
      return buildLogicalOp(new LogicalOp(next[0], first, next[1]), rest);
    }
  }

  var BinaryOp = Node.extend({
    node: 'binary_op',

    constructor: function(op, left, right) {
      this.op = op;
      this.left = left;
      this.right = right;
    },

    evaluate: function(ctx, done) {
      var _this = this;
      _this.left.eval_a(ctx, function(err, lres) {
        if (err) {
          done(err);
        } else {
          _this.right.eval_a(ctx, function(err, rres) {
            if (err) {
              done(err);
            } else {
              done(null, ctx.binaryop(_this.op, lres, rres));
            }
          });
        }
      });
    }
  });

  // take a chain of equal-precedence binary exprs and construct a left-folding tree
  function buildBinaryOp(first, rest) {
    if (rest.length == 0) {
      return first;
    } else {
      var next = rest.shift();
      return buildBinaryOp(new BinaryOp(next[0], first, next[1]), rest);
    }
  }

  // same, but fold right
  function buildBinaryOpRight(rest, last) {
    if (rest.length == 0) {
      return last;
    } else {
      var next = rest.pop();
      return buildBinaryOpRight(rest, new BinaryOp(next[0], next[1], last));
    }
  }

  var UnaryOp = Node.extend({
    node: 'unary_op',

    constructor: function(op, right) {
      this.op = op;
      this.right = right;
    },

    evaluate: function(ctx, done) {
      var _this = this;
      _this.right.eval_a(ctx, function(err, rres) {
        if (err) {
          done(err);
        } else {
          done(null, ctx.unaryop(_this.op, rres));
        }
      });
    }
  });
}

// Grammar

start
  = Statements

// Statements

Statements
  = EOL* stmts:Statement* {
      return new Statements(stmts);
    }

Statement
  = IfBlock
  / ForBlock
  / WhileBlock
  / BeginBlock
  / Assignment
  / CallStatement
  / FlowStatement
  / Comment

IfBlock
  = __ 'if' WB __ cond:Value EOL
    tstmts:Statements
    fstmts:(
      __ 'else' EOL
      s:Statements {
        return s;
      }
    )?
    __ 'end' EOL {
      return new IfBlock(cond, tstmts, fstmts);
    }

ForBlock
  = __ 'for' WB __ sym:Symbol __ 'in' WB __ range:Value EOL
    stmts:Statements
    __ 'end' EOL {
      return new ForBlock(sym, range, stmts);
    }

WhileBlock
  = __ 'while' WB __ cond:Value EOL
    stmts:Statements
    __ 'end' EOL {
      return new WhileBlock(cond, stmts);
    }

BeginBlock
  = __ 'begin' WB __ sym:Symbol EOL
    stmts:Statements
    __ 'end' EOL {
      return new BeginBlock(sym, stmts);
    }

Assignment
  = __ 'let' WB __ sym:Symbol
    indexes:(
      __ '[' __ v:Value ']' {
        return v;
      }
    )*
    __ '=' __ value:Value EOL {
      if (indexes.length == 0) {
        return new Assignment(sym, value);
      } else {
        return buildIndex(new Variable(sym), indexes, value);
      }
    }

CallStatement
  = __ target:(
      'call' WB __ e:IndexExpr { return e; }
      / sym:Symbol { return new Variable(sym); }
    )
    args:(
      __ v:Values? __ {
        return v;
      }
    )? EOL {
      return new Funcall(target, args);
    }

FlowStatement
  = __ 'break' EOL {
      return new Break;
    }
  / __ 'next' EOL {
      return new Next;
    }
  / __ 'return' result:( WB __ val:Value { return val; } )? EOL {
      return new Return(result);
    }

Comment
  = __ '--' __ text:$[^\n]* EOL {
      return new Comment(text);
    }

// Values

Values
  = first:Value rest:( __ ',' __ val:Value { return val; } )* {
      return [first].concat(rest);
    }

Value
  = CondExpr
  / AddExpr

// Conditions

CondExpr
  = first:NotExpr rest:( __ op:CondOp __ e:NotExpr { return [op, e]; } )* {
      return buildLogicalOp(first, rest);
    }

CondOp
  = 'and' WB { return 'and'; }
  / 'or'  WB { return 'or';  }

NotExpr
  = 'not' WB __ comp:RelExpr {
      return new LogicalOp('not', null, comp);
    }
  / RelExpr

RelExpr
  = left:AddExpr __ op:RelOp __ right:AddExpr {
      return new BinaryOp(op, left, right);
    }
  / '(' __ cond:CondExpr __ ')' {
      return cond;
    }

RelOp
  = '='
  / '!='
  / '<='
  / '<'
  / '>='
  / '>'

// Arithmetic

AddExpr
  = first:MultExpr rest:( __ op:AddOp __ e:MultExpr { return [op, e]; } )* {
      return buildBinaryOp(first, rest);
    }

AddOp
  = '+'
  / '-'

MultExpr
  = first:PowExpr rest:( __ op:MultOp __ e:PowExpr { return [op, e]; } )* {
      return buildBinaryOp(first, rest);
    }

MultOp
  = '*'
  / '/'
  / '%'

PowExpr
  = rest:(e:UnaryExpr __ op:PowOp __ { return [op, e]; } )* last:UnaryExpr {
      return buildBinaryOpRight(rest, last);
    }

PowOp
  = '^'

UnaryExpr
  = op:AddOp __ num:Number {
      // handle +/- number in the parser
      return new Literal(handle(num).unaryops[op](num));
    }
  / op:AddOp __ right:CallExpr {
      return new UnaryOp(op, right);
    }
  / CallExpr

// Invocation

CallExpr
  = target:IndexExpr __ '(' __ args:Values? __ ')' {
      return new Funcall(target, args);
    }
  / IndexExpr

// Index

IndexExpr
  = sym:Symbol indexes:( __ '[' __ v:Value ']' { return v; } )* {
      if (indexes.length == 0) {
        return new Variable(sym);
      } else {
        return buildIndex(new Variable(sym), indexes);
      }
    }
  / PrimaryExpr

PrimaryExpr
  = lit:Literal {
      return new Literal(lit);
    }
  / '(' __ val:Value __ ')' {
      return val;
    }

// Data

Literal
  = None
  / Boolean
  / Number
  / String

None
  = 'none' WB { return null; }

Boolean
  = 'true'  WB { return true; }
  / 'false' WB { return false; }

Number
  = 'infinity' WB { return Infinity; }
  / num:$( Digits ( '.' Digits )? ( [eE] [-+]? Digits )? ) {
      return parseFloat(num);
    }

Digits
  = $[0-9]+

String
  = '"' chars:Char* '"' { return chars.join(''); }

Char
  = '""' { return '"'; }
  / [^"]

Symbol
  = $( !Reserved [a-z_]i [a-z0-9_]i* )

Reserved
  = 'none'     WB
  / 'true'     WB
  / 'false'    WB
  / 'infinity' WB
  / 'if'       WB
  / 'else'     WB
  / 'end'      WB
  / 'for'      WB
  / 'in'       WB
  / 'while'    WB
  / 'begin'    WB
  / 'break'    WB
  / 'next'     WB
  / 'return'   WB
  / 'let'      WB
  / 'call'     WB
  / 'and'      WB
  / 'or'       WB
  / 'not'      WB

// Whitespace

WB
  = ![a-z_]i

__
  = [ \t]*

EOL
  = ( __ [\n;] )+
