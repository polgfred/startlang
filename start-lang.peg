// Language Nodes

{
  var start = require('./start-lib'),
      variables = {},
      procs = {},
      slice = [].slice,
      extend = function(object, properties) {
        var keys = Object.keys(properties);
        for (var i = 0; i < keys.length; ++i) {
          object[keys[i]] = properties[keys[i]];
        }
      };

  function Node() {}

  Node.extend = function(options) {
    var delegate = options.constructor,
        ctor = function() {
          // grab the info about where we are in the source
          this._text   = text();
          this._node   = this.node; // from proto
          this._offset = offset();
          this._line   = line();
          this._column = column();
          delegate.apply(this, arguments);
        };
    ctor.prototype = Object.create(Node.prototype);
    options.constructor = ctor;
    extend(ctor.prototype, options);
    return ctor;
  };

  var StatementsNode = Node.extend({
    node: 'stmts',

    constructor: function(stmts) {
      this.stmts = stmts;
    },

    run: function() {
      for (var i = 0; i < this.stmts.length; ++i) {
        this.stmts[i].run();
      }
    }
  });

  var IfNode = Node.extend({
    node: 'if',

    constructor: function(test, tstmts, fstmts) {
      this.test   = test;
      this.tstmts = tstmts;
      this.fstmts = fstmts;
    },

    run: function() {
      if (this.test.run()) {
        this.tstmts.run();
      } else if (this.fstmts) {
        this.fstmts.run();
      }
    }
  });

  var ForNode = Node.extend({
    node: 'for',

    constructor: function(name, start, end, by, stmts) {
      this.name  = name;
      this.start = start;
      this.end   = end;
      this.by    = by;
      this.stmts = stmts;
    },

    run: function() {
      for (var i = this.start.run(); i < this.end.run(); i += (this.by ? this.by.run() : 1)) {
        variables[this.name] = i;
        this.stmts.run();
      }
    }
  });

  var BeginNode = Node.extend({
    node: 'begin',

    constructor: function(name, stmts) {
      this.name  = name;
      this.stmts = stmts;
    },

    run: function() {
      procs[this.name] = this.stmts;
    }
  });

  var CallNode = Node.extend({
    node: 'call',

    constructor: function(name) {
      this.name = name;
    },

    run: function() {
      procs[this.name].run();
    }
  });

  var LetNode = Node.extend({
    node: 'let',

    constructor: function(name, indexes, value) {
      this.name = name;
      this.indexes = indexes;
      this.value = value;
    },

    run: function() {
      var value = this.value.run();

      if (this.indexes == null) {
        variables[this.name] = value;
      } else {
        if (variables[this.name]) {
          var indexes = this.indexes.map(function(index) {
            return index.run();
          });

          variables[this.name].set(indexes, value);
        }
      }
    }
  });

  var CommandNode = Node.extend({
    node: 'cmd',

    constructor: function(name, exprs) {
      this.name = name;
      this.exprs = exprs;
    },

    run: function() {
      // we'll eventually make this polymorphic
      if (this.name == 'print') {
        if (this.exprs) {
          for (var i = 0; i < this.exprs.length; ++i) {
            console.log(this.exprs[i].run());
          }
        } else {
          console.log();
        }
      }
    }
  });

  var CallNode = Node.extend({
    node: 'call',

    constructor: function(name, args) {
      this.name = name;
      this.args = args || [];
    },

    run: function() {
      if (start[this.name]) {
        var args = this.args.map(function(arg) {
          return arg.run();
        });

        return start[this.name].apply(null, args);
      }
    }
  });

  var IndexNode = Node.extend({
    node: 'index',

    constructor: function(name, indexes) {
      this.name = name;
      this.indexes = indexes;
    },

    run: function() {
      if (variables[this.name]) {
        var indexes = this.indexes.map(function(index) {
          return index.run();
        });

        return variables[this.name].get(indexes);
      }
    }
  });

  var BinaryOpNode = Node.extend({
    node: 'binary_op',

    constructor: function(op, left, right) {
      this.op    = op;
      this.left  = left;
      this.right = right;
    },

    run: function() {
      return binaryOps[this.op](this.left.run(), this.right.run());
    }
  });

  var binaryOps = {
    '+' : function(left, right) { return left +  right; },
    '-' : function(left, right) { return left -  right; },
    '*' : function(left, right) { return left *  right; },
    '/' : function(left, right) { return left /  right; },
    '%' : function(left, right) { return left %  right; },
    '=' : function(left, right) { return left == right; },
    '!=': function(left, right) { return left != right; },
    '<' : function(left, right) { return left <  right; },
    '<=': function(left, right) { return left <= right; },
    '>' : function(left, right) { return left >  right; },
    '>=': function(left, right) { return left >= right; }
  };

  // take a chain of equal-precedence binary exprs and construct a left-folding tree
  function buildBinaryOp(first, rest) {
    rest || (rest = []);

    var next;
    while (next = rest.shift()) {
      first = new BinaryOpNode(next[0], first, next[1]);
    }

    return first;
  }

  var LogicalOpNode = Node.extend({
    node: 'logical_op',

    constructor: function(op, left, right) {
      this.op    = op;
      this.left  = left;
      this.right = right;
    },

    run: function() {
      // logical ops short-circuit
      return logicalOps[this.op](this.left, this.right);
    }
  });

  var logicalOps = {
    'and': function(left, right) {
      return left.run() && right.run();
    },
    'or': function(left, right) {
      return left.run() || right.run();
    }
  };

  // take a chain of equal-precedence logical exprs and construct a left-folding tree
  function buildLogicalOp(first, rest) {
    rest || (rest = []);

    var next;
    while (next = rest.shift()) {
      first = new LogicalOpNode(next[0], first, next[1]);
    }

    return first;
  }

  var UnaryOpNode = Node.extend({
    node: 'unary_op',

    constructor: function(op, right) {
      this.op    = op;
      this.right = right;
    },

    run: function() {
      return unaryOps[this.op](this.right.run());
    }
  });

  var unaryOps = {
    '+' : function(right) { return + right; },
    '-' : function(right) { return - right; }
  };

  /*
  var XNode = Node.extend({

    constructor: function() {

    },

    run: function() {

    }
  });
  */

  var SymbolNode = Node.extend({
    node: 'symbol',

    constructor: function(name) {
      this.name = name;
    },

    run: function() {
      return this.name;
    }
  });

  var VarNode = Node.extend({
    node: 'var',

    constructor: function(name) {
      this.name = name;
    },

    run: function() {
      return variables[this.name];
    }
  });

  var LiteralNode = Node.extend({
    node: 'literal',

    constructor: function(value) {
      this.value = value;
    },

    run: function() {
      return this.value;
    }
  });
}

// Grammar

start
  = Statements

// Statements

Statements
  = EOL* stmts:Statement* {
      return new StatementsNode(stmts);
    }

Statement
  = IfBlock
  / ForBlock
  / BeginBlock
  / CallStatement
  / LetStatement
  / Command

IfBlock
  = __ 'if' __ test:LogicalExpr EOL
    tstmts:Statements
    fstmts:(
      __ 'else' EOL
      s:Statements {
        return s;
      }
    )?
    __ 'end' EOL {
      return new IfNode(test, tstmts, fstmts);
    }

ForBlock
  = __ 'for' __ sym:Symbol __ '=' __ start:Expr __ 'to' __ end:Expr
    by:(
      __ 'by' __ e:Expr {
        return e;
      }
    )?
    EOL
    stmts:Statements
    __ 'end' EOL {
      return new ForNode(sym, start, end, by, stmts);
    }

BeginBlock
  = __ 'begin' __ sym:Symbol EOL
    stmts:Statements
    __ 'end' EOL {
      return new BeginNode(sym, stmts);
    }

CallStatement
  = __ 'call' __ sym:Symbol EOL {
      return new CallNode(sym);
    }

LetStatement
  = __ 'let' __ sym:Symbol
    indexes:(
      __ '[' __ i:Exprs __ ']' {
        return i;
      }
    )?
    __ '=' __ value:Expr EOL {
      return new LetNode(sym, indexes, value);
    }

Command
  = __ name:CommandName __ exprs:Exprs? EOL {
      return new CommandNode(name, exprs);
    }

CommandName
  = 'print'
  / 'input'

// Expressions

LogicalExpr
  = first:RelExpr rest:( __ op:LogicalOp __ e:RelExpr { return [op, e]; } )* {
      return buildLogicalOp(first, rest);
    }

LogicalOp
  = 'and'
  / 'or'

RelExpr
  = left:AddExpr __ op:RelOp __ right:AddExpr {
      return new BinaryOpNode(op, left, right);
    }
  / '(' __ log:LogicalExpr __ ')' {
      return log;
    }

RelOp
  = '='
  / '!='
  / '<='
  / '<'
  / '>='
  / '>'

Exprs
  = first:Expr rest:( __ ',' __ e:Expr { return e; } )* {
      return [first].concat(rest);
    }

Expr
  = AddExpr

AddExpr
  = first:MultExpr rest:( __ op:AddOp __ e:MultExpr { return [op, e]; } )* {
      return buildBinaryOp(first, rest);
    }

AddOp
  = '+'
  / '-'

MultExpr
  = first:UnaryExpr rest:( __ op:MultOp __ e:UnaryExpr { return [op, e]; } )* {
      return buildBinaryOp(first, rest);
    }

MultOp
  = '*'
  / '/'
  / '%'

UnaryExpr
  // handle unary literals
  = op:AddOp __ right:Literal {
      return new LiteralNode(unaryOps[op](right));
    }
  / op:AddOp __ right:CallExpr {
      return new UnaryOpNode(op, right);
    }
  / CallExpr

CallExpr
  = sym:Symbol __ '(' __ args:Exprs? __ ')' {
      return new CallNode(sym, args);
    }
  / sym:Symbol __ '[' __ indexes:Exprs __ ']' {
      return new IndexNode(sym, indexes);
    }
  / PrimaryExpr

PrimaryExpr
  = lit:Literal {
      return new LiteralNode(lit);
    }
  / sym:Symbol {
      return new VarNode(sym);
    }
  / '(' __ expr:Expr __ ')' {
      return expr;
    }

// Data

Literal
  = Number
  / String

Number
  = 'NaN' { return NaN; }
  / 'Infinity' { return Infinity; }
  / num:$( Digits ( '.' Digits )? ( [eE] [-+]? Digits )? ) {
      return parseFloat(num);
    }

Symbol
  = $( [a-z_] [a-z0-9_]* )

Digits
  = $[0-9]+

String
  = '"' chars:Char* '"' { return chars.join(''); }

Char
  = '""' { return '"'; }
  / [^"]

// Whitespace
__
  = [ \t]*

EOL
  = ( __ [\r\n] )+
