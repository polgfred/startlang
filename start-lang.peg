// Language Nodes

{
  var variables = {},
      procs = {},
      slice = [].slice,
      extend = function(object, properties) {
        var keys = Object.keys(properties);
        for (var i = 0; i < keys.length; ++i) {
          object[keys[i]] = properties[keys[i]];
        }
      };

  function Node() {}

  Node.extend = function(options) {
    var delegate = options.constructor,
        ctor = function() {
          // grab the info about where we are in the source
          //this._text   = text();
          this._node   = this.node; // from proto
          this._offset = offset();
          this._line   = line();
          this._column = column();
          delegate.apply(this, arguments);
        };
    ctor.prototype = Object.create(Node.prototype);
    options.constructor = ctor;
    extend(ctor.prototype, options);
    return ctor;
  }

  var StmtsNode = Node.extend({
    node: 'stmts',
    constructor: function(stmts) {
      this.stmts = stmts;
    },
    run: function() {
      for (var i = 0; i < this.stmts.length; ++i) {
        this.stmts[i].run();
      }
    }
  });

  var IfNode = Node.extend({
    node: 'if',
    constructor: function(test, tstmts, fstmts) {
      this.test   = test;
      this.tstmts = tstmts;
      this.fstmts = fstmts;
    },
    run: function() {
      if (this.test.run()) {
        this.tstmts.run();
      } else {
        this.fstmts.run();
      }
    }
  });

  var ForNode = Node.extend({
    node: 'for',
    constructor: function(name, start, end, by, stmts) {
      this.name  = name;
      this.start = start;
      this.end   = end;
      this.by    = by;
      this.stmts = stmts;
    },
    run: function() {
      for (var i = this.start.run(); i < this.end.run(); i += (this.by ? this.by.run() : 1)) {
        variables[this.name] = i;
        this.stmts.run();
      }
    }
  });

  var BeginNode = Node.extend({
    node: 'begin',
    constructor: function(name, stmts) {
      this.name  = name;
      this.stmts = stmts;
    },
    run: function() {
      procs[this.name] = this.stmts;
    }
  });

  var CallNode = Node.extend({
    node: 'call',
    constructor: function(name) {
      this.name = name;
    },
    run: function() {
      procs[this.name].run();
    }
  });

  var CmdNode = Node.extend({
    node: 'cmd',
    constructor: function(name, exprs) {
      this.name = name;
      this.exprs = exprs;
    },
    run: function() {
      // we'll eventually make this polymorphic
      if (this.name == 'print') {
        if (this.exprs) {
          for (var i = 0; i < this.exprs.length; ++i) {
            console.log(this.exprs[i].run());
          }
        } else {
          console.log();
        }
      }
    }
  });

  var LetNode = Node.extend({
    node: 'let',
    constructor: function(name, value) {
      this.name = name;
      this.value = value;
    },
    run: function() {
      variables[this.name] = this.value.run();
    }
  });

  var BinaryOpNode = Node.extend({
    node: 'binary_op',
    constructor: function(op, left, right) {
      this.op    = op;
      this.left  = left;
      this.right = right;
    },
    run: function() {
      if (this.op == '+') {
        return this.left.run() + this.right.run();
      } else if (this.op == '-') {
        return this.left.run() - this.right.run();
      } else if (this.op == '*') {
        return this.left.run() * this.right.run();
      } else if (this.op == '/') {
        return this.left.run() / this.right.run();
      } else if (this.op == '%') {
        return this.left.run() % this.right.run();
      }
    }
  });

  var UnaryOpNode = Node.extend({
    node: 'unary_op',
    constructor: function(op, right) {
      this.op    = op;
      this.right = right;
    },
    run: function() {
      if (this.op == '+') {
        return + this.right.run();
      } else if (this.op == '-') {
        return - this.right.run();
      }
    }
  });

  var XNode = Node.extend({
    constructor: function() {

    },
    run: function() {

    }
  });

  var XNode = Node.extend({
    constructor: function() {

    },
    run: function() {

    }
  });

  var XNode = Node.extend({
    constructor: function() {

    },
    run: function() {

    }
  });

  var SymbolNode = Node.extend({
    node: 'symbol',
    constructor: function(name) {
      this.name = name;
    },
    run: function() {
      return this.name;
    }
  });

  var VarNode = Node.extend({
    node: 'var',
    constructor: function(name) {
      this.name = name;
    },
    run: function() {
      return variables[this.name];
    }
  });

  var ConstantNode = Node.extend({
    node: 'const',
    constructor: function(value) {
      this.value = value;
    },
    run: function() {
      return this.value;
    }
  });
}

// Grammar

start = Stmts

// Statements

Stmts
  = stmts:Stmt* {
      return new StmtsNode(stmts);
    }

Stmt
  = If
  / For
  / Begin
  / Call
  / Cmd
  / Let

If
  = __ 'if' __ test:Expr EOL
    tstmts:Stmts
    __ 'else' EOL
    fstmts:Stmts
    __ 'end' EOL {
      return new IfNode(test, tstmts, fstmts);
    }

For
  = __ 'for' __ sym:Symbol __ '=' __ start:Expr __ 'to' __ end:Expr by:( __ 'by' __ by:Expr { return by; } )? EOL
    stmts:Stmts
    __ 'end' EOL {
      return new ForNode(sym, start, end, by, stmts);
    }

Begin
  = __ 'begin' __ sym:Symbol EOL
    stmts:Stmts
    __ 'end' EOL {
      return new BeginNode(sym, stmts);
    }

Call
  = __ 'call' __ sym:Symbol EOL {
      return new CallNode(sym);
    }

Cmd
  = __ name:CmdName __ exprs:Exprs? EOL {
      return new CmdNode(name, exprs);
    }

CmdName
  = 'print'
  / 'input'

Let
  = __ 'let' __ sym:Symbol __ '=' __ value:Expr EOL {
      return new LetNode(sym, value);
    }

Symbol
  = first:[a-z_] rest:[a-z0-9_]* {
      return first + rest.join('');
    }

Constant
  = Number
  / String

Number
  = digits:([0-9])+ {
      return parseInt(digits.join(''), 10);
    }

String
  = '"' chars:Char* '"' {
      return chars.join('');
    }

Char
  = '""' { return '"'; }
  / [^"]

// Expressions

Exprs
  = first:Expr rest:( __ ',' __ expr:Expr { return expr; } )* {
      return [first].concat(rest);
    }

PrimaryExpr
  = num:Number  { return new ConstantNode(num); }
  / str:String  { return new ConstantNode(str); }
  / sym:Symbol  { return new VarNode(sym); }
  / '(' __ expr:Expr __ ')' {
      return expr;
    }

Expr
  = AddExpr

RelExpr
  = left:AddExpr __ op:RelOp __ right:AddExpr {
      return new BinaryOpNode(op, left, right);
    }

RelOp
  = '='
  / '!='
  / '<='
  / '<'
  / '>='
  / '>'

AddExpr
  = left:MultExpr __ op:AddOp __ right:MultExpr {
      return new BinaryOpNode(op, left, right);
    }
  / MultExpr

AddOp
  = '+'
  / '-'

MultExpr
  = left:UnaryExpr __ op:MultOp __ right:UnaryExpr {
      return new BinaryOpNode(op, left, right);
    }
  / UnaryExpr

MultOp
  = '*'
  / '/'
  / '%'

UnaryExpr
  = op:AddOp __ right:PrimaryExpr {
      return new UnaryOpNode(op, right);
    }
  / PrimaryExpr

// Whitespace

__ = [ \t]*

EOL = (__ [\r\n])+

