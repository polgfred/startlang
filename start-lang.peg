// Language Nodes

{
  function mixin(object, properties) {
    Object.keys(properties).forEach(function(prop) {
      object[prop] = properties[prop];
    });
  }

  function Node() {}

  Node.extend = function(options) {
    var delegate = options.constructor,
        ctor = function() {
          // grab the info about where we are in the source
          this._text = text();
          this._offset = offset();
          this._line = line();
          this._column = column();

          // copy from proto so we can inspect it
          this._node = this.node;

          delegate.apply(this, arguments);
        };

    ctor.prototype = Object.create(Node.prototype);
    options.constructor = ctor;
    mixin(ctor.prototype, options);
    return ctor;
  };

  var Statements = Node.extend({
    node: 'statements',

    constructor: function(stmts) {
      this.stmts = stmts;
    },

    run: function(ctx) {
      this.stmts.forEach(function(stmt) {
        stmt.run(ctx);
      });
    }
  });

  var IfBlock = Node.extend({
    node: 'if_block',

    constructor: function(cond, tstmts, fstmts) {
      this.cond = cond;
      this.tstmts = tstmts;
      this.fstmts = fstmts;
    },

    run: function(ctx) {
      if (this.cond.evaluate(ctx)) {
        this.tstmts.run(ctx);
      } else if (this.fstmts) {
        this.fstmts.run(ctx);
      }
    }
  });

  var ForBlock = Node.extend({
    node: 'for_block',

    constructor: function(name, start, end, by, stmts) {
      this.name = name;
      this.start = start;
      this.end = end;
      this.by = by;
      this.stmts = stmts;
    },

    run: function(ctx) {
      for (var i = this.start.evaluate(ctx);
            i < this.end.evaluate(ctx);
            i += (this.by ? this.by.evaluate(ctx) : 1)) {
        ctx.set(this.name, i);
        this.stmts.run(ctx);
      }
    }
  });

  var BeginBlock = Node.extend({
    node: 'begin_block',

    constructor: function(name, stmts) {
      this.name = name;
      this.stmts = stmts;
    },

    run: function(ctx) {
      ctx.set(this.name, ctx.createCallable(this.call.bind(this)));
    },

    call: function(ctx) {
      ctx.push();
      try {
        this.stmts.run(ctx);
      } finally {
        ctx.pop();
      }
    }
  });

  var Call = Node.extend({
    node: 'call',

    constructor: function(name, args) {
      this.name = name;
      this.args = args || [];
    },

    run: function(ctx) {
      this.evaluate(ctx);
    },

    evaluate: function(ctx) {
      return ctx.get(this.name).call(ctx, this.args.map(function(arg) {
        return arg.evaluate(ctx);
      }));
    }
  });

  var Command = Node.extend({
    node: 'command',

    constructor: function(name, exprs) {
      this.name = name;
      this.exprs = exprs;
    },

    run: function(ctx) {
      // we'll eventually make this polymorphic
      if (this.name == 'print') {
        if (this.exprs) {
          this.exprs.forEach(function(expr) {
            console.log(expr.evaluate(ctx));
          });
        } else {
          console.log();
        }
      }
    }
  });

  var Assignment = Node.extend({
    node: 'assignment',

    constructor: function(name, index, value) {
      this.name = name;
      this.index = index;
      this.value = value;
    },

    run: function(ctx) {
      if (this.index == null) {
        ctx.set(this.name, this.value.evaluate(ctx));
      } else {
        ctx.setIndex(this.name, this.index.map(function(dim) {
          return dim.evaluate(ctx);
        }), this.value.evaluate(ctx));
      }
    }
  });

  var Lookup = Node.extend({
    node: 'lookup',

    constructor: function(name, index) {
      this.name = name;
      this.index = index;
    },

    evaluate: function(ctx) {
      if (this.index == null) {
        return ctx.get(this.name);
      } else {
        return ctx.getIndex(this.name, this.index.map(function(dim) {
          return dim.evaluate(ctx);
        }));
      }
    }
  });

  var Comment = Node.extend({
    node: 'comment',

    constructor: function(text) {
      this.text = text;
    },

    run: function() {
    }
  });

  var Literal = Node.extend({
    node: 'literal',

    constructor: function(value) {
      this.value = value;
    },

    evaluate: function() {
      return this.value;
    }
  });

  var LogicalOp = Node.extend({
    node: 'logical_op',

    constructor: function(op, left, right) {
      this.op = op;
      this.left = left;
      this.right = right;
    },

    evaluate: function(ctx) {
      // logical ops short-circuit
      return logicalOps[this.op](ctx, this.left, this.right);
    }
  });

  var logicalOps = {
    'and': function(ctx, left, right) { return left.evaluate(ctx) && right.evaluate(ctx); },
    'or':  function(ctx, left, right) { return left.evaluate(ctx) || right.evaluate(ctx); },
    'not': function(ctx, left, right) { return ! right.evaluate(ctx); }
  };

  // take a chain of equal-precedence logical exprs and construct a left-folding tree
  function buildLogicalOp(first, rest) {
    rest || (rest = []);

    var next;
    while (next = rest.shift()) {
      first = new LogicalOp(next[0], first, next[1]);
    }

    return first;
  }

  var BinaryOp = Node.extend({
    node: 'binary_op',

    constructor: function(op, left, right) {
      this.op = op;
      this.left = left;
      this.right = right;
    },

    evaluate: function(ctx) {
      var left = this.left.evaluate(ctx),
          right = this.right.evaluate(ctx);

      this.validate(left, right);

      return binaryOps[this.op](left, right);
    },

    validate: function(left, right) {
      var op = this.op,
          lt = typeof left,
          rt = typeof right;

      if (lt != rt) {
        throw new Error('operands must be the same type');
      }

      if (lt != 'number') {
        if (op == '-' || op == '*' || op == '/' || op == '%') {
          throw new Error('operands must be numbers');
        } else if (lt != 'string') {
          throw new Error('operands must be numbers or strings');
        }
      }
    }
  });

  var binaryOps = {
    '+' : function(left, right) { return left +  right; },
    '-' : function(left, right) { return left -  right; },
    '*' : function(left, right) { return left *  right; },
    '/' : function(left, right) { return left /  right; },
    '%' : function(left, right) { return left %  right; },
    '=' : function(left, right) { return left == right; },
    '!=': function(left, right) { return left != right; },
    '<' : function(left, right) { return left <  right; },
    '<=': function(left, right) { return left <= right; },
    '>' : function(left, right) { return left >  right; },
    '>=': function(left, right) { return left >= right; }
  };

  // take a chain of equal-precedence binary exprs and construct a left-folding tree
  function buildBinaryOp(first, rest) {
    rest || (rest = []);

    var next;
    while (next = rest.shift()) {
      first = new BinaryOp(next[0], first, next[1]);
    }

    return first;
  }

  var UnaryOp = Node.extend({
    node: 'unary_op',

    constructor: function(op, right) {
      this.op = op;
      this.right = right;
    },

    evaluate: function(ctx) {
      var right = this.right.evaluate(ctx);

      this.validate(right);

      return unaryOps[this.op](right);
    },

    validate: function(right) {
      if (typeof right != 'number') {
        throw new Error('operand must be a number');
      }
    }
  });

  var unaryOps = {
    '+' : function(right) { return + right; },
    '-' : function(right) { return - right; }
  };
}

// Grammar

start
  = Statements

// Statements

Statements
  = EOL* stmts:Statement* {
      return new Statements(stmts);
    }

Statement
  = IfBlock
  / ForBlock
  / BeginBlock
  / Assignment
  / CallStatement
  / Command
  / Comment

IfBlock
  = __ 'if' __ cond:Condition EOL
    tstmts:Statements
    fstmts:(
      __ 'else' EOL
      s:Statements {
        return s;
      }
    )?
    __ 'end' EOL {
      return new IfBlock(cond, tstmts, fstmts);
    }

ForBlock
  = __ 'for' __ sym:Symbol __ '=' __ start:Value __ 'to' __ end:Value
    by:(
      __ 'by' __ val:Value {
        return e;
      }
    )?
    EOL
    stmts:Statements
    __ 'end' EOL {
      return new ForBlock(sym, start, end, by, stmts);
    }

BeginBlock
  = __ 'begin' __ sym:Symbol EOL
    stmts:Statements
    __ 'end' EOL {
      return new BeginBlock(sym, stmts);
    }

Assignment
  = __ 'let' __ sym:Symbol
    index:(
      __ '[' __ i:Values __ ']' {
        return i;
      }
    )?
    __ '=' __ value:Value EOL {
      return new Assignment(sym, index, value);
    }

CallStatement
  = __ 'call' __ sym:Symbol args:( __ '(' __ v:Values? __ ')' { return v; } )? EOL {
      return new Call(sym, args);
    }

Command
  = __ name:CommandName __ exprs:Values? EOL {
      return new Command(name, exprs);
    }

CommandName
  = 'print'
  / 'input'

Comment
  = __ '//' __ text:$[^\n]* EOL {
    return new Comment(text);
  }

// Conditions

Condition
  = ConjExpr

ConjExpr
  = first:NotExpr rest:( __ op:ConjOp __ e:NotExpr { return [op, e]; } )* {
      return buildLogicalOp(first, rest);
    }

ConjOp
  = 'and'
  / 'or'

NotExpr
  = 'not' __ comp:Comparison {
      return new LogicalOp('not', null, comp);
    }
  / Comparison

Comparison
  = left:Value __ op:RelOp __ right:Value {
      return new BinaryOp(op, left, right);
    }
  / '(' __ cond:Condition __ ')' {
      return cond;
    }

RelOp
  = '='
  / '!='
  / '<='
  / '<'
  / '>='
  / '>'

// Values

Values
  = first:Value rest:( __ ',' __ val:Value { return val; } )* {
      return [first].concat(rest);
    }

Value
  = AddExpr

AddExpr
  = first:MultExpr rest:( __ op:AddOp __ e:MultExpr { return [op, e]; } )* {
      return buildBinaryOp(first, rest);
    }

AddOp
  = '+'
  / '-'

MultExpr
  = first:UnaryExpr rest:( __ op:MultOp __ e:UnaryExpr { return [op, e]; } )* {
      return buildBinaryOp(first, rest);
    }

MultOp
  = '*'
  / '/'
  / '%'

UnaryExpr
  // handle negative numbers
  = op:AddOp __ num:Number {
      return new Literal(unaryOps[op](num));
    }
  / op:AddOp __ right:CallExpr {
      return new UnaryOp(op, right);
    }
  / CallExpr

CallExpr
  = sym:Symbol __ '(' __ args:Values? __ ')' {
      return new Call(sym, args);
    }
  / sym:Symbol __ '[' __ index:Values __ ']' {
      return new Lookup(sym, index);
    }
  / PrimaryExpr

PrimaryExpr
  = lit:Literal {
      return new Literal(lit);
    }
  / sym:Symbol {
      return new Lookup(sym);
    }
  / '(' __ val:Value __ ')' {
      return val;
    }

// Data

Literal
  = Number
  / String

Number
  = 'NaN' { return NaN; }
  / 'Infinity' { return Infinity; }
  / num:$( Digits ( '.' Digits )? ( [eE] [-+]? Digits )? ) {
      return parseFloat(num);
    }

Digits
  = $[0-9]+

String
  = '"' chars:Char* '"' { return chars.join(''); }

Char
  = '""' { return '"'; }
  / [^"]

Symbol
  = $( [a-z_] [a-z0-9_]* )

// Whitespace
__
  = [ \t]*

EOL
  = ( __ [\n;] )+
